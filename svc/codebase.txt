index.js "#!/usr/bin/env node

import chalk from 'chalk';
import inquirer from 'inquirer';
import readline from 'readline';
import {
    initProject,
    trackFiles,
    createSnapshot,
    deleteSnapshot,
    getDatabasePath,
    getProjectId,
} from './commands/snapshot.js';
import { revertToSnapshot, selectiveRestore } from './commands/revert.js';
import diffSnapshots from './commands/diff.js';
import { showHistory, listSnapshots } from './commands/history.js';
import { editIgnoreRules, previewIgnoredFiles } from '../utils/ignore.js';
import monitorFiles from './commands/monitor.js';
import { getSecretKey, regenerateSecretKey } from './commands/collaboration.js';
import fs from 'fs';

// Helper: Pause for user input
const pause = async () => {
    console.log(chalk.dim('\nPress Enter to return to the menu...'));
    await inquirer.prompt([{ type: 'input', name: 'pause', message: '' }]);
};

// Helper: Handle exit signals gracefully
const handleExit = (message = 'Exiting application...') => {
    console.log(chalk.yellow(`\n${message}`));
    process.exit(0);
};

// Block input to prevent interference
const blockInput = () => {
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    rl.pause();
    return rl;
};

// Unblock input after processing
const unblockInput = (rl) => {
    rl.close();
};

// Main menu
const mainMenu = async () => {
    let exit = false;

    while (!exit) {
        console.clear();
        console.log(chalk.bold.cyan('\nSimple Version Control (SVC) CLI\n'));

        const rl = blockInput();
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'Select a command:',
                choices: [
                    { name: 'Initialize Project', value: 'init' },
                    { name: 'Track Files', value: 'track' },
                    { name: 'Snapshot Management', value: 'snapshot' },
                    { name: 'Revert Options', value: 'revert' },
                    { name: 'View Diff', value: 'diff' },
                    { name: 'View History', value: 'history' },
                    { name: 'Ignore File Management', value: 'ignore' },
                    { name: 'Monitor Files (Real-Time)', value: 'monitor' },
                    { name: 'Collaboration Features', value: 'collaboration' },
                    { name: 'Exit', value: 'exit' },
                ],
            },
        ]);
        unblockInput(rl);

        switch (action) {
            case 'init':
                await taskHandler('Initialize Project', initProject);
                break;
            case 'track':
                await taskHandler('Track Files', trackFiles);
                break;
            case 'snapshot':
                await snapshotMenu();
                break;
            case 'revert':
                await revertMenu();
                break;
            case 'diff':
                await taskHandler('View Diff', diffSnapshots);
                break;
            case 'history':
                await taskHandler('View Snapshot History', showHistory);
                break;
            case 'ignore':
                await ignoreMenu();
                break;
            case 'monitor':
                await taskHandler('Monitor Files', monitorFiles);
                break;
            case 'collaboration':
                await collaborationMenu();
                break;
            case 'exit':
                handleExit();
                break;
            default:
                console.log(chalk.red('Invalid choice. Please try again.'));
        }
    }
};

// Helper: Task handler
const taskHandler = async (taskName, taskFunction) => {
    console.log(chalk.green(`Starting ${taskName}...`));
    try {
        await taskFunction();
        console.log(chalk.green(`${taskName} completed successfully.`));
        await pause();
    } catch (error) {
        console.error(chalk.red(`${taskName} failed. Error: ${error.message}`));
        await pause();
    }
};

// Ignore File Management Menu
const ignoreMenu = async () => {
    let back = false;

    while (!back) {
        console.clear();
        console.log(chalk.bold.yellow('\nIgnore File Management\n'));

        const rl = blockInput();
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'Choose an action:',
                choices: [
                    { name: 'Edit Ignore Rules', value: 'edit' },
                    { name: 'Preview Ignored Files', value: 'preview' },
                    { name: 'Back', value: 'back' },
                ],
            },
        ]);
        unblockInput(rl);

        switch (action) {
            case 'edit':
                await editIgnoreRules();
                await pause();
                break;
            case 'preview':
                await previewIgnoredFiles();
                await pause();
                break;
            case 'back':
                back = true;
                break;
            default:
                console.log(chalk.red('Invalid choice.'));
        }
    }
};

// Snapshot management menu
const snapshotMenu = async () => {
    let back = false;

    while (!back) {
        console.clear();
        console.log(chalk.bold.green('\nSnapshot Management\n'));

        const rl = blockInput();
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'Choose an action:',
                choices: [
                    { name: 'Create Snapshot', value: 'create' },
                    { name: 'Delete Snapshot', value: 'delete' },
                    { name: 'View Snapshots', value: 'list' },
                    { name: 'Back', value: 'back' },
                ],
            },
        ]);
        unblockInput(rl);

        switch (action) {
            case 'create':
                await createSnapshot();
                await pause();
                break;
            case 'delete':
                await deleteSnapshot();
                await pause();
                break;
            case 'list':
                await listSnapshots();
                await pause();
                break;
            case 'back':
                back = true;
                break;
            default:
                console.log(chalk.red('Invalid choice.'));
        }
    }
};

// Revert options menu
const revertMenu = async () => {
    let back = false;

    while (!back) {
        console.clear();
        console.log(chalk.bold.blue('\nRevert Options\n'));

        const rl = blockInput();
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'Choose an action:',
                choices: [
                    { name: 'Revert to Snapshot', value: 'revert' },
                    { name: 'Selective Revert', value: 'selective' },
                    { name: 'Back', value: 'back' },
                ],
            },
        ]);
        unblockInput(rl);

        switch (action) {
            case 'revert':
                await revertToSnapshot();
                await pause();
                break;
            case 'selective':
                await selectiveRestore();
                await pause();
                break;
            case 'back':
                back = true;
                break;
            default:
                console.log(chalk.red('Invalid choice.'));
        }
    }
};

// Collaboration menu
const collaborationMenu = async () => {
    const dbPath = getDatabasePath();
    if (!fs.existsSync(dbPath)) {
        console.log(chalk.red('No project initialized. Run "Initialize Project" first.'));
        await pause();
        return;
    }

    const projectId = await getProjectId();
    if (!projectId) {
        console.log(chalk.red('No active project found.'));
        await pause();
        return;
    }

    let back = false;

    while (!back) {
        console.clear();
        console.log(chalk.bold.magenta('\nCollaboration Features\n'));

        const rl = blockInput();
        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'Select a collaboration action:',
                choices: [
                    { name: 'Show Secret Key', value: 'show' },
                    { name: 'Regenerate Secret Key', value: 'regenerate' },
                    { name: 'Back', value: 'back' },
                ],
            },
        ]);
        unblockInput(rl);

        switch (action) {
            case 'show':
                try {
                    const secretKey = await getSecretKey(projectId);
                    console.log(chalk.green(`Secret Key: ${secretKey || 'Not found'}`));
                    await pause();
                } catch (error) {
                    console.error(chalk.red(`Error fetching secret key: ${error.message}`));
                    await pause();
                }
                break;
            case 'regenerate':
                try {
                    const newKey = await regenerateSecretKey(projectId);
                    console.log(chalk.green(`New Secret Key: ${newKey}`));
                    await pause();
                } catch (error) {
                    console.error(chalk.red(`Error regenerating secret key: ${error.message}`));
                    await pause();
                }
                break;
            case 'back':
                back = true;
                break;
            default:
                console.log(chalk.red('Invalid choice.'));
        }
    }
};

// Exit handlers
process.on('SIGINT', () => handleExit('Interrupt signal received. Exiting gracefully.'));
process.on('uncaughtException', (err) => {
    console.error(chalk.red(`Uncaught Exception: ${err.message}`));
    handleExit('Unexpected error occurred. Exiting.');
});

// Start CLI
mainMenu();

"
snapshot.js "import fs from 'fs';
import path from 'path';
import sqlite3 from 'sqlite3';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import { calculateFileHash } from '../../utils/hash.js';
import { loadIgnoreRules } from '../../utils/ignore.js';
import initDatabase from '../../database/init.js';

// Get the project name
const getProjectName = () => path.basename(process.cwd());

// Get the database path
const getDatabasePath = () => path.join(process.cwd(), `${getProjectName()}.db`);

// Retrieve the current project ID
const getProjectId = async () => {
    const dbPath = getDatabasePath();
    if (!fs.existsSync(dbPath)) {
        console.log(chalk.red('Project not initialized. Run "svc init" first.'));
        return null;
    }

    return new Promise((resolve, reject) => {
        const db = new sqlite3.Database(dbPath);
        db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], (err, project) => {
            if (err) {
                db.close();
                reject(err);
            } else {
                db.close();
                resolve(project ? project.id : null);
            }
        });
    });
};

// Initialize the project
const initProject = () => {
    console.clear();
    const spinner = ora('Initializing project...').start();
    const dbPath = getDatabasePath();
    const ignoreFilePath = path.join(process.cwd(), '.svcignore');

    if (fs.existsSync(dbPath)) {
        spinner.succeed(`Project "${getProjectName()}" is already initialized.`);
        return;
    }

    initDatabase(dbPath, () => {
        const db = new sqlite3.Database(dbPath);
        db.run(`INSERT INTO projects (name) VALUES (?)`, [getProjectName()], (err) => {
            if (err) {
                spinner.fail(`Error inserting project name: ${err.message}`);
            } else {
                spinner.succeed(`Project "${getProjectName()}" initialized successfully.`);
            }
        });
        db.close();
    });

    if (!fs.existsSync(ignoreFilePath)) {
        fs.writeFileSync(ignoreFilePath, ['node_modules/', '.git/', '*.log', '*.tmp', '*.db'].join('\n'));
        console.log(chalk.green(`.svcignore file created with default ignore patterns.`));
    }
};

// Track files
const trackFiles = () => {
    console.clear();
    const spinner = ora('Tracking files...').start();
    const dbPath = getDatabasePath();

    if (!fs.existsSync(dbPath)) {
        spinner.fail('Project not initialized. Run "svc init" first.');
        return;
    }

    const db = new sqlite3.Database(dbPath);
    const projectDir = process.cwd();
    const ignorePatterns = loadIgnoreRules();

    const traverseDirectory = (dir, projectId) => {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        entries.forEach((entry) => {
            const entryPath = path.relative(projectDir, path.join(dir, entry.name));
            if (ignorePatterns.some((pattern) => new RegExp(`^${pattern.replace(/\*/g, '.*')}$`).test(entryPath))) {
                console.log(chalk.gray(`Ignored: ${entryPath}`));
                return;
            }

            if (entry.isFile()) {
                const hash = calculateFileHash(path.join(projectDir, entryPath));
                db.get(`SELECT * FROM files WHERE path = ?`, [entryPath], (err, row) => {
                    if (row) {
                        db.run(`UPDATE files SET hash = ?, modified_at = CURRENT_TIMESTAMP WHERE path = ?`, [hash, entryPath]);
                    } else {
                        db.run(
                            `INSERT INTO files (path, hash, project_id, modified_at) VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
                            [entryPath, hash, projectId]
                        );
                    }
                });
            } else if (entry.isDirectory()) {
                traverseDirectory(path.join(dir, entry.name), projectId);
            }
        });
    };

    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], (err, project) => {
        if (err) {
            spinner.fail(`Error retrieving project: ${err.message}`);
        } else if (project) {
            traverseDirectory(projectDir, project.id);
            spinner.succeed('File tracking completed.');
        } else {
            spinner.fail('No project found for tracking.');
        }
        db.close();
    });
};

// Create a snapshot
const createSnapshot = async () => {
    console.clear();
    const spinner = ora('Creating snapshot...').start();
    const dbPath = getDatabasePath();

    if (!fs.existsSync(dbPath)) {
        spinner.fail('Project not initialized. Run "svc init" first.');
        return;
    }

    await trackFiles(); // Ensure files are up-to-date before taking a snapshot

    const db = new sqlite3.Database(dbPath);
    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], async (err, project) => {
        if (err) {
            spinner.fail(`Error retrieving project: ${err.message}`);
            return;
        }

        if (!project) {
            spinner.fail('No project found for snapshot creation.');
            return;
        }

        spinner.stop(); // Stop spinner before showing prompt
        const { description } = await inquirer.prompt([
            { type: 'input', name: 'description', message: 'Enter snapshot description:' },
        ]);
        spinner.start('Finalizing snapshot creation...');

        db.run(
            `INSERT INTO snapshots (project_id, description) VALUES (?, ?)`,
            [project.id, description],
            function (err) {
                if (err) {
                    spinner.fail(`Error creating snapshot: ${err.message}`);
                    return;
                }

                const snapshotId = this.lastID;
                db.all(`SELECT id, path FROM files WHERE project_id = ?`, [project.id], (err, files) => {
                    if (err) {
                        spinner.fail(`Error retrieving files: ${err.message}`);
                        return;
                    }

                    files.forEach((file) => {
                        const filePath = path.join(process.cwd(), file.path);
                        const content = fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf-8') : '';
                        db.run(
                            `INSERT INTO snapshot_files (snapshot_id, file_id, content) VALUES (?, ?, ?)`,
                            [snapshotId, file.id, content]
                        );
                    });
                });
                spinner.succeed(`Snapshot ${snapshotId} created successfully.`);
            }
        );
        db.close();
    });
};

// Delete a snapshot
const deleteSnapshot = async () => {
    console.clear();
    const spinner = ora('Deleting snapshot...').start();
    const dbPath = getDatabasePath();

    if (!fs.existsSync(dbPath)) {
        spinner.fail('Project not initialized. Run "svc init" first.');
        return;
    }

    const db = new sqlite3.Database(dbPath);
    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], async (err, project) => {
        if (err) {
            spinner.fail(`Error retrieving project: ${err.message}`);
            db.close();
            return;
        }

        if (!project) {
            spinner.fail('No project found for snapshot deletion.');
            db.close();
            return;
        }

        db.all(
            `SELECT id, description FROM snapshots WHERE project_id = ?`,
            [project.id],
            async (err, snapshots) => {
                if (err) {
                    spinner.fail(`Error retrieving snapshots: ${err.message}`);
                    db.close();
                    return;
                }

                if (snapshots.length === 0) {
                    spinner.fail('No snapshots available to delete.');
                    db.close();
                    return;
                }

                spinner.stop(); // Stop spinner before showing prompt
                const { snapshotId } = await inquirer.prompt([
                    {
                        type: 'list',
                        name: 'snapshotId',
                        message: 'Select snapshot to delete:',
                        choices: snapshots.map((snap) => ({
                            name: `${snap.id}: ${snap.description}`,
                            value: snap.id,
                        })),
                    },
                ]);
                spinner.start('Finalizing snapshot deletion...');

                db.run(`DELETE FROM snapshot_files WHERE snapshot_id = ?`, [snapshotId], (err) => {
                    if (err) {
                        spinner.fail(`Error deleting snapshot files: ${err.message}`);
                        db.close();
                        return;
                    }

                    db.run(`DELETE FROM snapshots WHERE id = ?`, [snapshotId], (err) => {
                        if (err) {
                            spinner.fail(`Error deleting snapshot: ${err.message}`);
                        } else {
                            spinner.succeed(`Snapshot ${snapshotId} deleted successfully.`);
                        }
                        db.close();
                    });
                });
            }
        );
    });
};

// Export functions
export { initProject, trackFiles, createSnapshot, deleteSnapshot, getDatabasePath, getProjectId };

"
ignore.js "import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import inquirer from 'inquirer';
import glob from 'glob';

// Get the `.svcignore` file path
const getIgnoreFilePath = () => path.join(process.cwd(), '.svcignore');

// Load existing rules from `.svcignore`
const loadIgnoreRules = () => {
    const ignoreFilePath = getIgnoreFilePath();
    if (!fs.existsSync(ignoreFilePath)) return [];
    return fs
        .readFileSync(ignoreFilePath, 'utf-8')
        .split('\n')
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith('#') && !line.startsWith('//')); // Skip comments
};

// Save updated rules back to `.svcignore`
const saveIgnoreRules = (rules) => {
    const ignoreFilePath = getIgnoreFilePath();
    try {
        fs.writeFileSync(ignoreFilePath, rules.join('\n') + '\n'); // Ensure a newline at the end
        console.log(chalk.green('Changes saved to `.svcignore`.'));
    } catch (error) {
        console.error(chalk.red(`Error saving ignore rules: ${error.message}`));
    }
};

// Validate a pattern
const validatePattern = (pattern) => {
    try {
        if (glob.hasMagic(pattern)) return true; // Ensure itâ€™s a valid glob pattern
        new RegExp(pattern); // Fallback: Test if it's a valid regex
        return true;
    } catch (e) {
        console.error(chalk.red(`Invalid pattern: "${pattern}"`));
        return false;
    }
};

// Preview files affected by `.svcignore` rules
const previewIgnoredFiles = () => {
    console.clear();
    const ignoreRules = loadIgnoreRules();
    const projectDir = process.cwd();

    if (ignoreRules.length === 0) {
        console.log(chalk.yellow('No ignore rules found in `.svcignore`.'));
        return;
    }

    console.log(chalk.cyan('\nPreview of ignored files:'));

    ignoreRules.forEach((rule) => {
        try {
            const matches = glob.sync(rule, { cwd: projectDir, dot: true });
            console.log(chalk.yellow(`\nRule: "${rule}"`));
            if (matches.length === 0) {
                console.log(chalk.gray('  No matching files or directories.'));
            } else {
                matches.forEach((match) => console.log(chalk.green(`  - ${match}`)));
            }
        } catch (err) {
            console.error(chalk.red(`Error processing rule "${rule}": ${err.message}`));
        }
    });
};

// Interactive menu for `.svcignore` management
const editIgnoreRules = async () => {
    let rules = loadIgnoreRules();
    let exit = false;

    while (!exit) {
        console.clear();
        console.log(chalk.cyan('\nCurrent `.svcignore` rules:'));
        if (rules.length === 0) {
            console.log(chalk.yellow('No rules found.'));
        } else {
            rules.forEach((rule, index) => console.log(`${index + 1}. ${rule}`));
        }
        console.log('');

        const { action } = await inquirer.prompt([
            {
                type: 'list',
                name: 'action',
                message: 'What would you like to do?',
                choices: [
                    { name: 'Add a new rule', value: 'add' },
                    { name: 'Remove an existing rule', value: 'remove' },
                    { name: 'Preview ignored files', value: 'preview' },
                    { name: 'Back to main menu', value: 'back' },
                    { name: 'Save changes and exit', value: 'save' },
                ],
            },
        ]);

        switch (action) {
            case 'add': {
                const { newRule } = await inquirer.prompt([
                    {
                        type: 'input',
                        name: 'newRule',
                        message: 'Enter a new ignore pattern (glob or regex):',
                        validate: (input) =>
                            input.trim() !== '' || 'Pattern cannot be empty.',
                    },
                ]);
                if (validatePattern(newRule)) {
                    rules.push(newRule.trim());
                    console.log(chalk.green(`Rule "${newRule}" added.`));
                }
                break;
            }

            case 'remove': {
                if (rules.length === 0) {
                    console.log(chalk.yellow('No rules to remove.'));
                    break;
                }

                const { ruleIndex } = await inquirer.prompt([
                    {
                        type: 'list',
                        name: 'ruleIndex',
                        message: 'Select a rule to remove:',
                        choices: rules.map((rule, index) => ({
                            name: rule,
                            value: index,
                        })),
                    },
                ]);
                console.log(chalk.red(`Rule "${rules[ruleIndex]}" removed.`));
                rules.splice(ruleIndex, 1);
                break;
            }

            case 'preview': {
                previewIgnoredFiles();
                await inquirer.prompt([{ type: 'input', name: 'continue', message: 'Press Enter to continue...' }]);
                break;
            }

            case 'back': {
                console.log(chalk.yellow('Returning to main menu...'));
                exit = true;
                break;
            }

            case 'save': {
                saveIgnoreRules(rules);
                exit = true;
                break;
            }

            default:
                console.log(chalk.red('Invalid option.'));
        }
    }
};

// Export functions
export { editIgnoreRules, loadIgnoreRules, saveIgnoreRules, previewIgnoredFiles };

" revert.js "import path from 'path';
import sqlite3 from 'sqlite3';
import fs from 'fs';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';

// Get the project name
const getProjectName = () => path.basename(process.cwd());

// Get the database path
const getDatabasePath = () => path.join(process.cwd(), `${getProjectName()}.db`);

// Helper function for file restoration
const restoreFile = (filePath, content) => {
    try {
        fs.mkdirSync(path.dirname(filePath), { recursive: true });
        fs.writeFileSync(filePath, content || '', 'utf-8');
        return { success: true };
    } catch (err) {
        return { success: false, error: err.message };
    }
};

// Revert all files to a specific snapshot
const revertToSnapshot = async () => {
    const spinner = ora('Loading snapshots...').start();
    const dbPath = getDatabasePath();

    if (!fs.existsSync(dbPath)) {
        spinner.fail('Project not initialized. Run "svc init" first.');
        return;
    }

    const db = new sqlite3.Database(dbPath);

    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], async (err, project) => {
        if (err || !project) {
            spinner.fail(`Error finding project "${getProjectName()}".`);
            db.close();
            return;
        }

        db.all(
            `SELECT id, description, created_at FROM snapshots WHERE project_id = ? ORDER BY created_at ASC`,
            [project.id],
            async (err, snapshots) => {
                if (err || snapshots.length === 0) {
                    spinner.fail('No snapshots found for this project.');
                    db.close();
                    return;
                }

                spinner.stop();

                const { snapshotId } = await inquirer.prompt([
                    {
                        type: 'list',
                        name: 'snapshotId',
                        message: 'Select a snapshot to revert to:',
                        choices: snapshots.map((snap) => ({
                            name: `${snap.id}: ${snap.description} (${snap.created_at})`,
                            value: snap.id,
                        })),
                    },
                ]);

                spinner.start('Reverting all files...');
                db.all(
                    `SELECT f.path, sf.content
                     FROM snapshot_files sf
                     INNER JOIN files f ON sf.file_id = f.id
                     WHERE sf.snapshot_id = ?`,
                    [snapshotId],
                    (err, files) => {
                        if (err || files.length === 0) {
                            spinner.fail('No files found in the selected snapshot.');
                            db.close();
                            return;
                        }

                        files.forEach((file) => {
                            const filePath = path.join(process.cwd(), file.path);
                            const result = restoreFile(filePath, file.content);
                            if (result.success) {
                                console.log(chalk.green(`Restored: ${file.path}`));
                            } else {
                                console.log(chalk.red(`Failed to restore ${file.path}: ${result.error}`));
                            }
                        });

                        spinner.succeed(`Reverted to snapshot ID: ${snapshotId}`);
                        db.close();
                    }
                );
            }
        );
    });
};

// Selectively restore files from a snapshot
const selectiveRestore = async () => {
    const spinner = ora('Loading snapshots...').start();
    const dbPath = getDatabasePath();

    if (!fs.existsSync(dbPath)) {
        spinner.fail('Project not initialized. Run "svc init" first.');
        return;
    }

    const db = new sqlite3.Database(dbPath);

    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], async (err, project) => {
        if (err || !project) {
            spinner.fail(`Error finding project "${getProjectName()}".`);
            db.close();
            return;
        }

        db.all(
            `SELECT id, description, created_at FROM snapshots WHERE project_id = ? ORDER BY created_at ASC`,
            [project.id],
            async (err, snapshots) => {
                if (err || snapshots.length === 0) {
                    spinner.fail('No snapshots found for this project.');
                    db.close();
                    return;
                }

                spinner.stop();

                const { snapshotId } = await inquirer.prompt([
                    {
                        type: 'list',
                        name: 'snapshotId',
                        message: 'Select a snapshot to restore from:',
                        choices: snapshots.map((snap) => ({
                            name: `${snap.id}: ${snap.description} (${snap.created_at})`,
                            value: snap.id,
                        })),
                    },
                ]);

                db.all(
                    `SELECT f.path, sf.content 
                     FROM snapshot_files sf
                     INNER JOIN files f ON sf.file_id = f.id
                     WHERE sf.snapshot_id = ?`,
                    [snapshotId],
                    async (err, files) => {
                        if (err || files.length === 0) {
                            console.log(chalk.yellow('No files found in the selected snapshot.'));
                            db.close();
                            return;
                        }

                        const { selectedFiles } = await inquirer.prompt([
                            {
                                type: 'checkbox',
                                name: 'selectedFiles',
                                message: 'Select files to restore:',
                                choices: files.map((file) => ({
                                    name: file.path,
                                    value: file,
                                })),
                                validate: (input) =>
                                    input.length > 0
                                        ? true
                                        : 'You must select at least one file to proceed.',
                            },
                        ]);

                        // Ensure no restoration happens if no files are explicitly selected
                        if (!selectedFiles || selectedFiles.length === 0) {
                            console.log(chalk.yellow('No files selected for restoration.'));
                            db.close();
                            return;
                        }

                        const restoreSpinner = ora('Restoring selected files...').start();

                        selectedFiles.forEach((file) => {
                            const filePath = path.join(process.cwd(), file.path);
                            const result = restoreFile(filePath, file.content);

                            if (result.success) {
                                console.log(chalk.green(`Restored: ${file.path}`));
                            } else {
                                console.log(chalk.red(`Failed to restore ${file.path}: ${result.error}`));
                            }
                        });

                        restoreSpinner.succeed('Selective file restoration completed.');
                        db.close();
                    }
                );
            }
        );
    });
};




export { revertToSnapshot, selectiveRestore };



" diff.js "import path from 'path';
import sqlite3 from 'sqlite3';
import fs from 'fs';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { diffLines } from 'diff';
import Table from 'cli-table3';
import readline from 'readline';
import ora from 'ora';

// Get the project name
const getProjectName = () => path.basename(process.cwd());

// Get the database path
const getDatabasePath = () => path.join(process.cwd(), `${getProjectName()}.db`);

// Block and unblock input to prevent interference
const blockInput = () => {
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    rl.pause(); // Pause the input
    return rl;
};

const unblockInput = (rl) => {
    rl.close(); // Resume input by closing readline
};

// Filter files by extension or directory
const filterFiles = (files, filter) => {
    if (!filter) return files;

    const { fileType, directory } = filter;
    return files.filter((file) => {
        const matchesType = fileType ? file.path.endsWith(fileType) : true;
        const matchesDir = directory ? file.path.startsWith(directory) : true;
        return matchesType && matchesDir;
    });
};

// Display side-by-side diff using cli-table3
const displaySideBySideDiff = (filePath, content1, content2) => {
    const diffs = diffLines(content1, content2);

    const table = new Table({
        head: [chalk.blue('Old Version'), chalk.green('New Version')],
        colWidths: [50, 50],
    });

    diffs.forEach((part) => {
        const left = part.removed ? chalk.red(part.value.trim()) : part.added ? '' : chalk.gray(part.value.trim());
        const right = part.added ? chalk.green(part.value.trim()) : part.removed ? '' : chalk.gray(part.value.trim());
        table.push([left, right]);
    });

    console.log(chalk.yellow(`\nFile: ${filePath}`));
    console.log(table.toString());
};

// Compare two snapshots
const diffSnapshots = async () => {
    console.clear(); // Clear the console for a clean interface
    const dbPath = getDatabasePath();
    if (!fs.existsSync(dbPath)) {
        console.error(chalk.red(`Project not initialized. Run "svc init" first.`));
        return;
    }

    const rl = blockInput(); // Block input during snapshot diff

    try {
        const db = new sqlite3.Database(dbPath);

        const project = await new Promise((resolve, reject) =>
            db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], (err, result) => {
                if (err) return reject(err);
                resolve(result);
            })
        );

        if (!project) {
            console.error(chalk.red(`Error finding project "${getProjectName()}". Ensure it is initialized.`));
            return;
        }

        const snapshots = await new Promise((resolve, reject) =>
            db.all(
                `SELECT id, description, created_at FROM snapshots WHERE project_id = ? ORDER BY created_at ASC`,
                [project.id],
                (err, rows) => {
                    if (err) return reject(err);
                    resolve(rows);
                }
            )
        );

        if (snapshots.length < 2) {
            console.log(chalk.yellow('Not enough snapshots to compare.'));
            return;
        }

        const { snapshotIds } = await inquirer.prompt([
            {
                type: 'checkbox',
                name: 'snapshotIds',
                message: 'Select two snapshots to compare:',
                choices: snapshots.map((snap) => ({
                    name: `${snap.id}: ${snap.description} (${snap.created_at})`,
                    value: snap.id,
                })),
                validate: (input) => input.length === 2 || 'Please select exactly two snapshots.',
            },
        ]);

        const [snapshot1, snapshot2] = snapshotIds;

        const filterOptions = await inquirer.prompt([
            {
                type: 'input',
                name: 'fileType',
                message: 'Filter by file type (e.g., .js, .css). Leave blank for no filter:',
                default: '',
            },
            {
                type: 'input',
                name: 'directory',
                message: 'Filter by directory (e.g., src/). Leave blank for no filter:',
                default: '',
            },
        ]);

        console.log('\n'); // Add spacing before starting the spinner
        const spinner = ora('Processing snapshot comparison...').start();

        const files = await new Promise((resolve, reject) =>
            db.all(
                `SELECT sf.snapshot_id, f.path, sf.content
                 FROM snapshot_files sf
                 INNER JOIN files f ON sf.file_id = f.id
                 WHERE sf.snapshot_id IN (?, ?)`,
                [snapshot1, snapshot2],
                (err, rows) => {
                    if (err) return reject(err);
                    resolve(rows);
                }
            )
        );

        const filesBySnapshot = files.reduce((acc, file) => {
            if (!acc[file.snapshot_id]) acc[file.snapshot_id] = {};
            acc[file.snapshot_id][file.path] = file.content || '';
            return acc;
        }, {});

        const files1 = filesBySnapshot[snapshot1] || {};
        const files2 = filesBySnapshot[snapshot2] || {};

        const filteredFiles = filterFiles(
            Object.keys({ ...files1, ...files2 }).map((path) => ({
                path,
                content1: files1[path] || '',
                content2: files2[path] || '',
            })),
            filterOptions
        );

        spinner.stop(); // Stop the spinner before displaying results

        if (filteredFiles.length === 0) {
            console.log(chalk.yellow('No matching files found based on the filter criteria.'));
        } else {
            console.log(chalk.bold.green(`\nDiff Between Snapshots ${snapshot1} and ${snapshot2}:`));
            filteredFiles.forEach(({ path, content1, content2 }) =>
                displaySideBySideDiff(path, content1, content2)
            );
        }

        db.close();
    } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
    } finally {
        unblockInput(rl); // Unblock input even in case of an error
    }
};

export default diffSnapshots;
"



 history.js "import path from 'path';
import sqlite3 from 'sqlite3';
import chalk from 'chalk';
import inquirer from 'inquirer';
import fs from 'fs';

// Get the project name
const getProjectName = () => path.basename(process.cwd());

// Get the database path
const getDatabasePath = () => path.join(process.cwd(), `${getProjectName()}.db`);

// Show snapshot history
const showHistory = async () => {
    const dbPath = getDatabasePath();
    if (!fs.existsSync(dbPath)) {
        console.error(chalk.red(`Project not initialized. Run "svc init" first.`));
        return;
    }

    const db = new sqlite3.Database(dbPath);
    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], (err, project) => {
        if (err || !project) {
            console.error(chalk.red(`Error finding project "${getProjectName()}". Ensure it is initialized.`));
            db.close();
            return;
        }

        db.all(
            `SELECT id, description, created_at FROM snapshots WHERE project_id = ? ORDER BY created_at ASC`,
            [project.id],
            (err, snapshots) => {
                if (err || snapshots.length === 0) {
                    console.log(chalk.yellow('No snapshots found.'));
                    db.close();
                    return;
                }

                console.log(chalk.green(`Snapshot History for "${getProjectName()}":`));
                snapshots.forEach((snap) => {
                    console.log(
                        chalk.cyan(`ID: ${snap.id}\nDescription: ${snap.description}\nCreated At: ${snap.created_at}\n`)
                    );
                });

                db.close();
            }
        );
    });
};

// List all snapshots
const listSnapshots = async () => {
    const dbPath = getDatabasePath();
    if (!fs.existsSync(dbPath)) {
        console.error(chalk.red(`Project not initialized. Run "svc init" first.`));
        return;
    }

    const db = new sqlite3.Database(dbPath);
    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], (err, project) => {
        if (err || !project) {
            console.error(chalk.red(`Error finding project "${getProjectName()}". Ensure it is initialized.`));
            db.close();
            return;
        }

        db.all(
            `SELECT id, description, created_at FROM snapshots WHERE project_id = ? ORDER BY created_at ASC`,
            [project.id],
            (err, snapshots) => {
                if (err || snapshots.length === 0) {
                    console.log(chalk.yellow('No snapshots found.'));
                    db.close();
                    return;
                }

                console.log(chalk.green('Available Snapshots:'));
                snapshots.forEach((snap) => {
                    console.log(`ID: ${snap.id} | Description: ${snap.description} | Created At: ${snap.created_at}`);
                });

                db.close();
            }
        );
    });
};

// Export both functions
export { showHistory, listSnapshots };

"



delete.js "import path from 'path';
import sqlite3 from 'sqlite3';
import chalk from 'chalk';
import inquirer from 'inquirer';
import fs from 'fs';

// Get the project name
const getProjectName = () => path.basename(process.cwd());

// Get the database path
const getDatabasePath = () => path.join(process.cwd(), `${getProjectName()}.db`);

// Delete a snapshot
const deleteSnapshot = async () => {
    const dbPath = getDatabasePath();
    if (!fs.existsSync(dbPath)) {
        console.error(chalk.red(`Project not initialized. Run "svc init" first.`));
        return;
    }

    const db = new sqlite3.Database(dbPath);
    db.get(`SELECT id FROM projects WHERE name = ?`, [getProjectName()], async (err, project) => {
        if (err || !project) {
            console.error(chalk.red(`Error finding project "${getProjectName()}". Ensure it is initialized.`));
            db.close();
            return;
        }

        db.all(
            `SELECT id, description, created_at FROM snapshots WHERE project_id = ? ORDER BY created_at ASC`,
            [project.id],
            async (err, snapshots) => {
                if (err || snapshots.length === 0) {
                    console.log(chalk.yellow('No snapshots found for this project.'));
                    db.close();
                    return;
                }

                const { snapshotId } = await inquirer.prompt([
                    {
                        type: 'list',
                        name: 'snapshotId',
                        message: 'Select a snapshot to delete:',
                        choices: snapshots.map((snap) => ({
                            name: `${snap.id}: ${snap.description} (${snap.created_at})`,
                            value: snap.id,
                        })),
                    },
                ]);

                // Confirm before deletion
                const { confirm } = await inquirer.prompt([
                    {
                        type: 'confirm',
                        name: 'confirm',
                        message: `Are you sure you want to delete snapshot ID ${snapshotId}?`,
                        default: false,
                    },
                ]);

                if (!confirm) {
                    console.log(chalk.yellow('Snapshot deletion canceled.'));
                    db.close();
                    return;
                }

                // Delete snapshot and associated files
                db.run(
                    `DELETE FROM snapshot_files WHERE snapshot_id = ?`,
                    [snapshotId],
                    (err) => {
                        if (err) {
                            console.error(chalk.red('Error deleting snapshot files:'), err.message);
                            db.close();
                            return;
                        }

                        db.run(
                            `DELETE FROM snapshots WHERE id = ?`,
                            [snapshotId],
                            (err) => {
                                if (err) {
                                    console.error(chalk.red('Error deleting snapshot:'), err.message);
                                } else {
                                    console.log(chalk.green(`Snapshot with ID ${snapshotId} deleted successfully.`));
                                }
                                db.close();
                            }
                        );
                    }
                );
            }
        );
    });
};

export default deleteSnapshot;
"


init.js "import sqlite3 from 'sqlite3';
import chalk from 'chalk';

const initDatabase = (dbPath, callback) => {
    const db = new sqlite3.Database(dbPath);

    db.serialize(() => {
        console.log(chalk.cyan('Initializing database and ensuring tables are up to date...'));

        // Create `projects` table if it doesn't exist
        db.run(`
            CREATE TABLE IF NOT EXISTS projects (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Check if `secret_key` column exists in `projects` table
        db.all(`PRAGMA table_info(projects)`, (err, columns) => {
            if (err) {
                console.error(chalk.red('Error retrieving table schema:'), err.message);
                return;
            }

            const columnExists = columns.some((column) => column.name === 'secret_key');
            console.log(chalk.yellow(`Does "secret_key" column exist? ${columnExists}`));

            if (!columnExists) {
                console.log(chalk.blue('Adding "secret_key" column to "projects" table...'));
                db.run(
                    `ALTER TABLE projects ADD COLUMN secret_key TEXT`,
                    (alterErr) => {
                        if (alterErr) {
                            console.error(chalk.red('Error adding "secret_key" column:'), alterErr.message);
                        } else {
                            console.log(chalk.green('"secret_key" column successfully added.'));
                        }
                    }
                );
            } else {
                console.log(chalk.green('"secret_key" column already exists.'));
            }
        });

        // Create `files` table
        db.run(`
            CREATE TABLE IF NOT EXISTS files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER,
                path TEXT NOT NULL UNIQUE,
                hash TEXT,
                content TEXT,
                modified_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (project_id) REFERENCES projects(id)
            )
        `);

        // Create `snapshots` table
        db.run(`
            CREATE TABLE IF NOT EXISTS snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER,
                description TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (project_id) REFERENCES projects(id)
            )
        `);

        // Create `snapshot_files` table
        db.run(`
            CREATE TABLE IF NOT EXISTS snapshot_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                snapshot_id INTEGER,
                file_id INTEGER,
                content TEXT,
                FOREIGN KEY (snapshot_id) REFERENCES snapshots(id),
                FOREIGN KEY (file_id) REFERENCES files(id)
            )
        `, (err) => {
            if (err) {
                console.error(chalk.red('Error creating tables:'), err.message);
            } else {
                console.log(chalk.green('Database tables created successfully.'));
                if (callback) callback();
            }
        });
    });

    db.close((err) => {
        if (err) console.error(chalk.red('Error closing the database:'), err.message);
        else console.log(chalk.green('Database handle closed successfully.'));
    });
};

export default initDatabase;
"





collabiration.js "import crypto from 'crypto';
import sqlite3 from 'sqlite3';
import chalk from 'chalk';
import { getDatabasePath } from './snapshot.js';

// Generate a random secret key
const generateSecretKey = () => {
    return crypto.randomBytes(16).toString('hex');
};

// Ensure the `secret_key` column exists in the `projects` table
const ensureSecretKeyColumn = async () => {
    const dbPath = getDatabasePath();
    const db = new sqlite3.Database(dbPath);

    return new Promise((resolve, reject) => {
        db.all(`PRAGMA table_info(projects)`, (err, columns) => {
            if (err) {
                db.close();
                return reject(err);
            }

            const columnExists = columns.some((column) => column.name === 'secret_key');
            if (!columnExists) {
                db.run(`ALTER TABLE projects ADD COLUMN secret_key TEXT`, (alterErr) => {
                    if (alterErr) {
                        db.close();
                        return reject(alterErr);
                    }
                    console.log(chalk.green('Added "secret_key" column to "projects" table.'));
                    db.close();
                    resolve(true);
                });
            } else {
                db.close();
                resolve(false);
            }
        });
    });
};

// Retrieve or generate a secret key for the current project
const getSecretKey = async (projectId) => {
    await ensureSecretKeyColumn();

    const dbPath = getDatabasePath();
    const db = new sqlite3.Database(dbPath);

    return new Promise((resolve, reject) => {
        db.get(`SELECT secret_key FROM projects WHERE id = ?`, [projectId], (err, row) => {
            if (err) {
                db.close();
                return reject(err);
            }

            if (row && row.secret_key) {
                db.close();
                resolve(row.secret_key);
            } else {
                const newKey = generateSecretKey();
                db.run(
                    `UPDATE projects SET secret_key = ? WHERE id = ?`,
                    [newKey, projectId],
                    (updateErr) => {
                        db.close();
                        if (updateErr) return reject(updateErr);
                        resolve(newKey);
                    }
                );
            }
        });
    });
};

// Regenerate a new secret key for the current project
const regenerateSecretKey = async (projectId) => {
    await ensureSecretKeyColumn();

    const dbPath = getDatabasePath();
    const db = new sqlite3.Database(dbPath);
    const newKey = generateSecretKey();

    return new Promise((resolve, reject) => {
        db.run(
            `UPDATE projects SET secret_key = ? WHERE id = ?`,
            [newKey, projectId],
            (err) => {
                db.close();
                if (err) return reject(err);
                resolve(newKey);
            }
        );
    });
};

export { generateSecretKey, getSecretKey, regenerateSecretKey };
"


hash.js "import fs from 'fs';
import crypto from 'crypto';

// Function to calculate the hash of a file
export const calculateFileHash = (filePath) => {
    const fileBuffer = fs.readFileSync(filePath);
    const hashSum = crypto.createHash('sha256');
    hashSum.update(fileBuffer);
    return hashSum.digest('hex');
};
"



monitor.js "import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';
import chokidar from 'chokidar';
import debounce from 'lodash.debounce';

// Maintain categorized changes
const monitoredChanges = { added: [], modified: [], deleted: [] };

// Helper: Format timestamped logs
const logWithTimestamp = (message, color = chalk.white) => {
    const timestamp = new Date().toISOString();
    console.log(color(`[${timestamp}] ${message}`));
};

// Helper: Process file change events
const processFileChange = (eventType, filePath, baseDir) => {
    const relativePath = path.relative(baseDir, filePath);
    switch (eventType) {
        case 'add':
            if (!monitoredChanges.added.includes(relativePath)) monitoredChanges.added.push(relativePath);
            break;
        case 'change':
            if (!monitoredChanges.modified.includes(relativePath)) monitoredChanges.modified.push(relativePath);
            break;
        case 'unlink':
            if (!monitoredChanges.deleted.includes(relativePath)) monitoredChanges.deleted.push(relativePath);
            break;
        default:
            break;
    }
};

// Helper: Categorize and display changes
const categorizeChanges = () => {
    console.log(chalk.cyan('\nSummary of Detected Changes:\n'));
    ['added', 'modified', 'deleted'].forEach((type) => {
        if (monitoredChanges[type].length > 0) {
            console.log(chalk.bold(`${type.toUpperCase()}:`));
            monitoredChanges[type].forEach((file) => console.log(chalk.green(`  - ${file}`)));
        }
    });
};

// Handle Interactive Prompts for Changes
const handleInteractivePrompts = async (baseDir) => {
    for (const type of ['added', 'modified', 'deleted']) {
        for (const file of monitoredChanges[type]) {
            const { action } = await inquirer.prompt([
                {
                    type: 'list',
                    name: 'action',
                    message: `Detected "${type}" for ${file}. What would you like to do?`,
                    choices: [
                        { name: 'Track File', value: 'track' },
                        { name: 'Ignore Permanently', value: 'ignore' },
                        { name: 'Skip', value: 'skip' },
                    ],
                },
            ]);

            switch (action) {
                case 'track':
                    logWithTimestamp(`Tracking ${file}...`, chalk.green);
                    // Add your logic to track the file (e.g., database update).
                    break;
                case 'ignore':
                    logWithTimestamp(`Ignoring ${file}...`, chalk.red);
                    const ignoreFilePath = path.join(baseDir, '.svcignore');
                    fs.appendFileSync(ignoreFilePath, `${file}\n`);
                    logWithTimestamp(`Added ${file} to .svcignore`, chalk.green);
                    break;
                case 'skip':
                    logWithTimestamp(`Skipping ${file}.`, chalk.yellow);
                    break;
                default:
                    console.log(chalk.red('Invalid action selected.'));
            }
        }
    }

    // Clear monitored changes after handling them
    monitoredChanges.added = [];
    monitoredChanges.modified = [];
    monitoredChanges.deleted = [];
};

// Real-Time Monitoring Function
const monitorFiles = () => {
    return new Promise((resolve, reject) => {
        const baseDir = process.cwd();
        const spinner = ora('Starting real-time file monitoring...').start();

        const watcher = chokidar.watch(baseDir, {
            ignored: /node_modules|\.git/,
            persistent: true,
            ignoreInitial: true,
        });

        watcher
            .on('add', (filePath) => {
                logWithTimestamp(`File added: ${filePath}`, chalk.green);
                processFileChange('add', filePath, baseDir);
            })
            .on('change', debounce((filePath) => {
                logWithTimestamp(`File modified: ${filePath}`, chalk.blue);
                processFileChange('change', filePath, baseDir);
            }, 300))
            .on('unlink', (filePath) => {
                logWithTimestamp(`File deleted: ${filePath}`, chalk.red);
                processFileChange('unlink', filePath, baseDir);
            })
            .on('error', (error) => {
                logWithTimestamp(`Watcher error: ${error.message}`, chalk.red);
                spinner.fail('Monitoring encountered an error.');
                watcher.close();
                reject(error);
            });

        // Graceful shutdown on SIGINT
        process.on('SIGINT', async () => {
            spinner.stop();
            console.log(chalk.blue('\nStopping file monitoring...'));

            // Show detected changes
            categorizeChanges();

            // Handle prompts for changes
            await handleInteractivePrompts(baseDir);

            watcher.close();
            resolve();
        });

        spinner.succeed('Monitoring started. Press Ctrl+C to stop.');
    });
};

export default monitorFiles;
"